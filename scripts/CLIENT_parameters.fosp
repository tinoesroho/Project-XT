                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  

shared class Sprite
{
	void Load(string&name,int path=(0))
	{
		if(name.length()>0)
		Id=LoadSprite(name,path);
		else
		Id=0;
		LoadedNameHash=uint(-1);
		RefreshData();
	}
	
	void Load(uint nameHash)
	{
		if(nameHash==LoadedNameHash)
		return;
		LoadedNameHash=nameHash;
		
		Id=LoadSprite(nameHash);
		RefreshData();
	}
	
	void LoadByIni(string&iniKey,int path)
	{
		string@name=GetIfaceIniStr(iniKey);
		if(@name!=null&&name.length()>0)
		Id=LoadSprite(name,path);
		else
		Id=0;
		LoadedNameHash=uint(-1);
		RefreshData();
	} 
	
	void Draw(int x,int y,int w=0,int h=0,int cornerX=-1,int cornerY=-1)
	{
		if(Id==0||Hidden)
		return;
		
		if(w==0)
		w=Width;
		if(h==0)
		h=Height;
		
		if(AnimPlay)
		{
			uint ticksPerFrame=Ticks/FrmCount;
			int framesPassed=(GetTick()-AnimStartTick)/ticksPerFrame;
			if(framesPassed>0)
			{
				AnimStartTick+=framesPassed*ticksPerFrame;
				Frame+=(AnimReverse?-framesPassed:framesPassed);
				
				bool endAnim=false;
				if(Frame<=0)
				{
					endAnim=true;
					AnimStartTick-=-Frame*ticksPerFrame;
					Frame=0;
				}
				else if(Frame>=int(FrmCount)-1)
				{
					endAnim=true;
					AnimStartTick-=(Frame+1-FrmCount)*ticksPerFrame;
					Frame=FrmCount-1;
				}
				
				if(endAnim)
				{
					if(AnimLoop)
					Frame=(AnimReverse?int(FrmCount)-1:0);
					else
					AnimPlay=false;
				}
			}
		}
		
		if(cornerX==0)
		x-=w/2;
		else if(cornerX==1)
		x-=w;
		if(cornerY==0)
		y-=h/2;
		else if(cornerY==1)
		y-=h;
		
		switch(Layout)
		{
			case(1):
			DrawSpritePattern(Id,Frame,x,y,w,h,Width,Height);
			break;
			case(2):
			DrawSprite(Id,Frame,x+w/2-Width/2,y+h/2-Height/2);
			break;
			case(3):
			DrawSprite(Id,Frame,x,y,w,h);
			break;
			case(4):
			DrawSprite(Id,Frame,x,y,w,h,true);
			break;
			default:
			DrawSprite(Id,Frame,x,y);
			break;
		}
	}
	
	void SetFrame(int index)
	{
		Frame=index;
		AnimPlay=false;
	}
	
	void SetFirstFrame()
	{
		SetFrame(0);
	}
	
	void SetLastFrame()
	{
		SetFrame(int(FrmCount)-1);
	}
	
	void PlayAnimation(bool loop=true,bool reverse=false)
	{
		if(Id==0)
		return;
		if(AnimPlay&&AnimLoop==loop&&AnimReverse==reverse)
		return;
		
		AnimPlay=true;
		AnimLoop=loop;
		AnimReverse=reverse;
		AnimStartTick=GetTick();
	}
	
	private void RefreshData()
	{
		if(Id!=0)
		{
			Width=GetSpriteWidth(Id,0);
			Height=GetSpriteHeight(Id,0);
			FrmCount=GetSpriteCount(Id);
			Ticks=GetSpriteTicks(Id);
		}
		else
		{
			Width=0;
			Height=0;
			FrmCount=0;
			Ticks=0;
		}
	}
	
	uint Id;
	int Frame=-1;
	int Layout=(0);
	int Width;
	int Height;
	uint FrmCount;
	uint Ticks;
	bool AnimPlay;
	bool AnimLoop;
	bool AnimReverse;
	uint AnimStartTick;
	bool Hidden;
	uint LoadedNameHash;
}         

shared class Serializator
{
	uint8[]Array;
	uint CurPos;
	uint BufSize;
	uint DataSize;
	
	Serializator()
	{
		CurPos=0;
		BufSize=0;
		DataSize=0;
	}
	
	Serializator(uint approxSize)
	{
		CurPos=0;
		BufSize=0;
		DataSize=0;
		GrowBuffer(approxSize);
	}
	
	void GrowBuffer(uint size)
	{
		if(size<=BufSize)
		return;
		if(BufSize==0)
		BufSize=1;
		while(size>BufSize)
		BufSize*=2;
		Array.resize(BufSize);
	}
	
	bool Save(string&name)
	{
		if(DataSize==0)
		return false;   
		
		SetCacheData(name,Array,DataSize);
		bool result=true;
		
		Clear();
		return result;
	}
	
	bool Load(string&name)
	{
		Clear();    
		
		if(not GetCacheData(name,Array))
		return false;
		
		BufSize=Array.length();
		DataSize=BufSize;
		return true;
	}
	
	void Clear()
	{
		CurPos=0;
		BufSize=0;
		DataSize=0;
	}
	
	Serializator&SetCurPos(uint pos)
	{
		GrowBuffer(pos);
		CurPos=pos;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator&Fill(uint8 value,uint length)
	{
		GrowBuffer(CurPos+length);
		for(uint i=0;i<length;i++)
		Array[CurPos++]=value;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator&Set(const int64&value)
	{
		GrowBuffer(CurPos+8);
		Array[CurPos++]=(value>>56)&0xFF;
		Array[CurPos++]=(value>>48)&0xFF;
		Array[CurPos++]=(value>>40)&0xFF;
		Array[CurPos++]=(value>>32)&0xFF;
		Array[CurPos++]=(value>>24)&0xFF;
		Array[CurPos++]=(value>>16)&0xFF;
		Array[CurPos++]=(value>>8)&0xFF;
		Array[CurPos++]=value&0xFF;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator&Set(const int32&value)
	{
		GrowBuffer(CurPos+4);
		Array[CurPos++]=(value>>24)&0xFF;
		Array[CurPos++]=(value>>16)&0xFF;
		Array[CurPos++]=(value>>8)&0xFF;
		Array[CurPos++]=value&0xFF;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator&Set(const int16&value)
	{
		GrowBuffer(CurPos+2);
		Array[CurPos++]=(value>>8)&0xFF;
		Array[CurPos++]=value&0xFF;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator&Set(const int8&value)
	{
		GrowBuffer(CurPos+1);
		Array[CurPos++]=value;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator&Set(const uint64&value)
	{
		GrowBuffer(CurPos+8);
		Array[CurPos++]=(value>>56)&0xFF;
		Array[CurPos++]=(value>>48)&0xFF;
		Array[CurPos++]=(value>>40)&0xFF;
		Array[CurPos++]=(value>>32)&0xFF;
		Array[CurPos++]=(value>>24)&0xFF;
		Array[CurPos++]=(value>>16)&0xFF;
		Array[CurPos++]=(value>>8)&0xFF;
		Array[CurPos++]=value&0xFF;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator&Set(const uint32&value)
	{
		GrowBuffer(CurPos+4);
		Array[CurPos++]=(value>>24)&0xFF;
		Array[CurPos++]=(value>>16)&0xFF;
		Array[CurPos++]=(value>>8)&0xFF;
		Array[CurPos++]=value&0xFF;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator&Set(const uint16&value)
	{
		GrowBuffer(CurPos+2);
		Array[CurPos++]=(value>>8)&0xFF;
		Array[CurPos++]=value&0xFF;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator&Set(const uint8&value)
	{
		GrowBuffer(CurPos+1);
		Array[CurPos++]=value;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator&Set(const bool&value)
	{
		GrowBuffer(CurPos+1);
		Array[CurPos++]=value?1:0;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator&Set(const string&value)
	{
		uint len=value.rawLength();
		GrowBuffer(CurPos+len+1);
		for(uint i=0;i<len;i++)
		Array[CurPos++]=value.rawGet(i);
		Array[CurPos++]=0;
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator&Set(const int64[]&values)
	{
		uint valuesLen=values.length();
		uint len=4+valuesLen*8;
		GrowBuffer(CurPos+len);
		Set(valuesLen);
		for(uint i=0,j=valuesLen;i<j;i++)
		Set(values[i]);
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator&Set(const int32[]&values)
	{
		uint valuesLen=values.length();
		uint len=4+valuesLen*4;
		GrowBuffer(CurPos+len);
		Set(valuesLen);
		for(uint i=0,j=valuesLen;i<j;i++)
		Set(values[i]);
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator&Set(const int16[]&values)
	{
		uint valuesLen=values.length();
		uint len=4+valuesLen*2;
		GrowBuffer(CurPos+len);
		Set(valuesLen);
		for(uint i=0,j=valuesLen;i<j;i++)
		Set(values[i]);
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator&Set(const int8[]&values)
	{
		uint valuesLen=values.length();
		uint len=4+valuesLen;
		GrowBuffer(CurPos+len);
		Set(valuesLen);
		for(uint i=0,j=valuesLen;i<j;i++)
		Set(values[i]);
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator&Set(const uint64[]&values)
	{
		uint valuesLen=values.length();
		uint len=4+valuesLen*8;
		GrowBuffer(CurPos+len);
		Set(valuesLen);
		for(uint i=0,j=valuesLen;i<j;i++)
		Set(values[i]);
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator&Set(const uint32[]&values)
	{
		uint valuesLen=values.length();
		uint len=4+valuesLen*4;
		GrowBuffer(CurPos+len);
		Set(valuesLen);
		for(uint i=0,j=valuesLen;i<j;i++)
		Set(values[i]);
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator&Set(const uint16[]&values)
	{
		uint valuesLen=values.length();
		uint len=4+valuesLen*2;
		GrowBuffer(CurPos+len);
		Set(valuesLen);
		for(uint i=0,j=valuesLen;i<j;i++)
		Set(values[i]);
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator&Set(const uint8[]&values)
	{
		uint valuesLen=values.length();
		uint len=4+valuesLen;
		GrowBuffer(CurPos+len);
		Set(valuesLen);
		for(uint i=0,j=valuesLen;i<j;i++)
		Set(values[i]);
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator&Set(const bool[]&values)
	{
		uint valuesLen=values.length();
		uint len=4+valuesLen;
		GrowBuffer(CurPos+len);
		Set(valuesLen);
		for(uint i=0,j=valuesLen;i<j;i++)
		Set(values[i]);
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}
	
	Serializator&Set(const string[]&values)
	{
		uint valuesLen=values.length();
		uint len=4+valuesLen;
		for(uint i=0,j=valuesLen;i<j;i++)
		len+=values[i].length();
		GrowBuffer(CurPos+len);
		Set(valuesLen);
		for(uint i=0,j=valuesLen;i<j;i++)
		Set(values[i]);
		if(CurPos>DataSize)
		DataSize=CurPos;
		return this;
	}                            
	
	Serializator&Get(int64&value)
	{
		value=0;
		if(CurPos+8>DataSize)
		return this;
		value|=Array[CurPos++]<<56;
		value|=Array[CurPos++]<<48;
		value|=Array[CurPos++]<<40;
		value|=Array[CurPos++]<<32;
		value|=Array[CurPos++]<<24;
		value|=Array[CurPos++]<<16;
		value|=Array[CurPos++]<<8;
		value|=Array[CurPos++];
		return this;
	}
	
	Serializator&Get(int32&value)
	{
		value=0;
		if(CurPos+4>DataSize)
		return this;
		value|=Array[CurPos++]<<24;
		value|=Array[CurPos++]<<16;
		value|=Array[CurPos++]<<8;
		value|=Array[CurPos++];
		return this;
	}
	
	Serializator&Get(int16&value)
	{
		value=0;
		if(CurPos+2>DataSize)
		return this;
		value|=Array[CurPos++]<<8;
		value|=Array[CurPos++];
		return this;
	}
	
	Serializator&Get(int8&value)
	{
		value=0;
		if(CurPos+1>DataSize)
		return this;
		value=Array[CurPos++];
		return this;
	}
	
	Serializator&Get(uint64&value)
	{
		value=0;
		if(CurPos+8>DataSize)
		return this;
		value|=Array[CurPos++]<<56;
		value|=Array[CurPos++]<<48;
		value|=Array[CurPos++]<<40;
		value|=Array[CurPos++]<<32;
		value|=Array[CurPos++]<<24;
		value|=Array[CurPos++]<<16;
		value|=Array[CurPos++]<<8;
		value|=Array[CurPos++];
		return this;
	}
	
	Serializator&Get(uint32&value)
	{
		value=0;
		if(CurPos+4>DataSize)
		return this;
		value|=Array[CurPos++]<<24;
		value|=Array[CurPos++]<<16;
		value|=Array[CurPos++]<<8;
		value|=Array[CurPos++];
		return this;
	}
	
	Serializator&Get(uint16&value)
	{
		value=0;
		if(CurPos+2>DataSize)
		return this;
		value|=Array[CurPos++]<<8;
		value|=Array[CurPos++];
		return this;
	}
	
	Serializator&Get(uint8&value)
	{
		value=0;
		if(CurPos+1>DataSize)
		return this;
		value=Array[CurPos++];
		return this;
	}
	
	Serializator&Get(bool&value)
	{
		value=false;
		if(CurPos+1>DataSize)
		return this;
		value=Array[CurPos++]==1?true:false;
		return this;
	}
	
	Serializator&Get(string&str)
	{
		uint len=0;
		for(uint i=CurPos;;i++)
		{
			if(i==DataSize)
			{
				str="";
				return this;
			}
			if(Array[i]==0)
			{
				len=i-CurPos;
				break;
			}
		}
		str.rawResize(len);
		for(uint i=0;i<len;i++)
		str.rawSet(i,Array[CurPos++]);
		CurPos++;
		return this;
	}
	
	Serializator&Get(int64[]&values)
	{
		uint valuesLen=0;
		Get(valuesLen);
		values.resize(valuesLen);
		for(uint i=0;i<valuesLen;i++)
		Get(values[i]);
		return this;
	}
	
	Serializator&Get(int32[]&values)
	{
		uint valuesLen=0;
		Get(valuesLen);
		values.resize(valuesLen);
		for(uint i=0;i<valuesLen;i++)
		Get(values[i]);
		return this;
	}
	
	Serializator&Get(int16[]&values)
	{
		uint valuesLen=0;
		Get(valuesLen);
		values.resize(valuesLen);
		for(uint i=0;i<valuesLen;i++)
		Get(values[i]);
		return this;
	}
	
	Serializator&Get(int8[]&values)
	{
		uint valuesLen=0;
		Get(valuesLen);
		values.resize(valuesLen);
		for(uint i=0;i<valuesLen;i++)
		Get(values[i]);
		return this;
	}
	
	Serializator&Get(uint64[]&values)
	{
		uint valuesLen=0;
		Get(valuesLen);
		values.resize(valuesLen);
		for(uint i=0;i<valuesLen;i++)
		Get(values[i]);
		return this;
	}
	
	Serializator&Get(uint32[]&values)
	{
		uint valuesLen=0;
		Get(valuesLen);
		values.resize(valuesLen);
		for(uint i=0;i<valuesLen;i++)
		Get(values[i]);
		return this;
	}
	
	Serializator&Get(uint16[]&values)
	{
		uint valuesLen=0;
		Get(valuesLen);
		values.resize(valuesLen);
		for(uint i=0;i<valuesLen;i++)
		Get(values[i]);
		return this;
	}
	
	Serializator&Get(uint8[]&values)
	{
		uint valuesLen=0;
		Get(valuesLen);
		values.resize(valuesLen);
		for(uint i=0;i<valuesLen;i++)
		Get(values[i]);
		return this;
	}
	
	Serializator&Get(bool[]&values)
	{
		uint valuesLen=0;
		Get(valuesLen);
		values.resize(valuesLen);
		for(uint i=0;i<valuesLen;i++)
		Get(values[i]);
		return this;
	}
	
	Serializator&Get(string[]&values)
	{
		uint valuesLen=0;
		Get(valuesLen);
		values.resize(valuesLen);
		for(uint i=0;i<valuesLen;i++)
		Get(values[i]);
		return this;
	}                             
	
};   

funcdef bool DragAndDropHandler(GUIObject&obj,GUIObject@target);  

import void GUI_RegisterScreen(int screenIndex,GUIScreen&screen)from"gui";
import GUIScreen@GUI_GetScreen(int screenIndex)from"gui";
import GUIScreen@GUI_GetActiveMainScreen()from"gui";
import GUIScreen@GUI_GetActiveScreen()from"gui";
import void GUI_GetActiveScreens(GUIScreen@[]&result)from"gui";
import GUIObject@GUI_GetFocusedObject()from"gui";
import void GUI_SetFocusedObject(GUIObject@obj)from"gui";
import GUIObject@GUI_GetPressedObject()from"gui";
import GUIObject@GUI_GetDraggedObject()from"gui";
import GUIObject@GUI_GetHoveredObject()from"gui";
import void GUI_NextTextInput()from"gui";
import void GUI_CollectMessageBoxes(GUIMessageBox@[]&messageBoxes)from"gui";
import bool GUI_IsConsoleActive()from"gui";
import void GUI_AddDragAndDropHandler(DragAndDropHandler@handler)from"gui"; 

import void GUI_EngineCallback_Start()from"gui";
import void GUI_EngineCallback_ShowScreen(int screenIndex,dictionary@params)from"gui";
import void GUI_EngineCallback_HideScreen(int screenIndex)from"gui";
import void GUI_EngineCallback_Draw(bool mainScreen)from"gui";
import void GUI_EngineCallback_DrawCursor()from"gui";
import void GUI_EngineCallback_MouseDown(int button)from"gui";
import void GUI_EngineCallback_MouseUp(int button)from"gui";
import void GUI_EngineCallback_MouseMove()from"gui";
import void GUI_EngineCallback_KeyDown(uint8 key,string@text)from"gui";
import void GUI_EngineCallback_KeyUp(uint8 key)from"gui";
import void GUI_EngineCallback_InputLost()from"gui";
import void GUI_EngineCallback_Loop()from"gui";
import void GUI_EngineCallback_GetActiveScreens(int[]&result)from"gui";
import void GUI_EngineCallback_ItemChanged(bool onMap)from"gui";
import bool GUI_EngineCallback_CheckInterfaceHit(int x,int y)from"gui";
import void GUI_Callback_OnResolutionChanged()from"gui";
import void GUI_Callback_OnLanguageChanged()from"gui";                                                                                                                                                                                                                    

shared class GUIObject
{
	bool get_Active()final{return _ActiveSelf&&(_Parent!is null?_Parent.Active:true);}
	bool get_ActiveSelf()final{return _ActiveSelf;}
	string@get_Name()final{return _Name;}
	int get_PosX()final{return _Parent!is null?_AbsolutePosX-_Parent._AbsolutePosX:_AbsolutePosX;}
	int get_PosY()final{return _Parent!is null?_AbsolutePosY-_Parent._AbsolutePosY:_AbsolutePosY;}
	int get_AbsolutePosX()final{return _AbsolutePosX;}
	int get_AbsolutePosY()final{return _AbsolutePosY;}
	int get_Width()final{return _Width;}
	int get_Height()final{return _Height;}
	int get_Anchor()final{return _Anchor;}
	int get_Dock()final{return _Dock;}
	bool get_IsDraggable()final{return _IsDraggable;}
	bool get_IsNotHittable()final{return _IsNotHittable;}
	bool get_CheckTransparentOnHit()final{return _CheckTransparentOnHit;}
	bool get_IsFocused()final{return _IsFocused;}
	bool get_IsPressed()final{return _IsPressed;}
	bool get_IsHovered()final{return _IsHovered;}
	bool get_IsDragged()final{return _IsDragged||(_Parent!is null&&_Parent.IsDragged);}
	uint get_ChildCount()final{return _Children.length();}
	GUIObject@get_Parent()final{return _Parent;}
	GUIScreen@get_Screen()final{return _Parent!is null?_Parent.Screen:cast<GUIScreen>(this);}
	GUIGrid@get_Grid()final{return _Grid;}
	uint get_CellIndex()final{return _CellIndex;}
	
	bool _ActiveSelf;
	string@_Name;
	int _BasePosX;
	int _BasePosY;
	int _BaseWidth;
	int _BaseHeight;
	int _AbsolutePosX;
	int _AbsolutePosY;
	int _Width;
	int _Height;
	int _Anchor;
	int _Dock;
	bool _IsDragged;
	bool _IsDraggable;
	bool _IsNotHittable;
	bool _CheckTransparentOnHit;
	bool _DeferredMousePressed;
	bool _IsFocused;
	bool _IsPressed;
	bool _IsHovered;
	int _PressedButton;
	int _PressedX;
	int _PressedY;
	uint _PressedRepeatTime;
	GUIObject@_Parent;
	GUIObject@[]_Children;
	GUIGrid@_Grid;
	uint _CellIndex; 
	
	void OnConstruct(){}
	void OnInit(){}
	void OnShow(){}
	void OnShow(dictionary@params){}
	void OnHide(){}
	void OnAppear(){}
	void OnAppear(dictionary@params){}
	void OnDisappear(){}
	void OnRemove(){}
	void OnDraw(){}
	void OnMove(int deltaX,int deltaY){}
	void OnMouseDown(int button){}
	void OnMouseUp(int button,bool lost){}
	void OnMousePressed(int button){}
	void OnLMousePressed(){}
	void OnRMousePressed(){}
	void OnMouseClick(int button){}
	void OnLMouseClick(){}
	void OnRMouseClick(){}
	void OnMouseMove(){}
	void OnGlobalMouseDown(int button){}
	void OnGlobalMouseUp(int button){}
	void OnGlobalMousePressed(int button){}
	void OnGlobalMouseClick(int button){}
	void OnGlobalMouseMove(){}
	void OnInput(){}
	void OnInput(uint8 key){}
	void OnInput(string&text){}
	void OnInput(uint8 key,string@text){}
	void OnGlobalInput(uint8 key,string@text){}
	void OnActiveChanged(){}
	void OnFocusChanged(){}
	void OnHoverChanged(){}
	void OnDragChanged(){}
	void OnResizeGrid(GUIObject@cell,uint cellIndex){}
	void OnDrawItem(ItemCl@item,GUIObject@cell,uint cellIndex){}
	
	void Init(GUIObject@parent)
	{
		_ActiveSelf=true;
		@_Name=reflection::typeof<GUIObject>(this).nameWithoutNamespace;
		
		if(_Parent!is null)
		_Parent._Children.removeAt(_Parent._Children.findByRef(this));
		@_Parent=parent;
		if(parent!is null)
		parent._Children.insertLast(this);
		
		_Construct();
		
		GUIScreen@screen=Screen;
		if(screen!is null&&screen._IsRegistered)
		_Init();
		
		_RefreshPosition();
	}
	
	void _Construct()
	{
		OnConstruct();
	}
	
	void _Init()
	{
		OnInit();
		for(uint i=0;i<_Children.length();i++)
		_Children[i]._Init();
	}
	
	void _Show(dictionary@params)
	{
		OnShow();
		OnShow(params);
		for(uint i=0;i<_Children.length();i++)
		_Children[i]._Show(params);
	}
	
	void _Hide()
	{
		OnHide();
		for(uint i=0;i<_Children.length();i++)
		_Children[i]._Hide();
	}
	
	void _Appear(dictionary@params)
	{
		OnAppear();
		OnAppear(params);
		for(uint i=0;i<_Children.length();i++)
		_Children[i]._Appear(params);
	}
	
	void _Disappear()
	{
		OnDisappear();
		for(uint i=0;i<_Children.length();i++)
		_Children[i]._Disappear();
	}
	
	void Remove()
	{
		if(_Parent!is null)
		{
			_Parent._Children.removeAt(_Parent._Children.findByRef(this));
			@_Parent=null;
		}
		
		_Remove();
		
		_ActiveSelf=false;
	}
	
	void _Remove()
	{
		OnRemove();
		for(uint i=0;i<_Children.length();i++)
		_Children[i]._Remove();
	}
	
	void _Reload(bool reconstruct,bool refreshPosition)
	{
		if(reconstruct)
		OnConstruct();
		if(refreshPosition)
		_RefreshPosition();
		
		for(uint i=0;i<_Children.length();i++)
		_Children[i]._Reload(reconstruct,refreshPosition);
	}
	
	void _DrawCallback()
	{
		
		if(_Grid!is null)
		{
			GUIItemView@itemView=cast<GUIItemView>(_Grid);
			if(itemView!is null)
			OnDrawItem(itemView.GetItem(_CellIndex),this,_CellIndex);
		} 
		
		OnDraw();
	}
	
	void _Draw(bool callCallback)
	{
		if(callCallback)
		_DrawCallback(); 
		
		for(uint i=0;i<_Children.length();i++)
		{
			GUIObject@child=_Children[i];
			if(child._ActiveSelf&&!child._IsDragged)
			child._Draw(true);
		}
	}
	
	void Draw(int x,int y)
	{
		int dx=x-_AbsolutePosX;
		int dy=y-_AbsolutePosY;
		_Move(dx,dy,false,false);
		_Draw(true);
		_Move(-dx,-dy,false,false);
	}
	
	void Move(int deltaX,int deltaY)
	{
		_Move(deltaX,deltaY,true,true);
	}
	
	void _Move(int deltaX,int deltaY,bool callCallback,bool moveBasePos)
	{
		_AbsolutePosX+=deltaX;
		_AbsolutePosY+=deltaY;
		
		if(moveBasePos)
		{
			_BasePosX+=deltaX;
			_BasePosY+=deltaY;
		}
		
		for(uint i=0;i<_Children.length();i++)
		_Children[i]._Move(deltaX,deltaY,false,false);
		
		if(callCallback)
		_MoveCallback(deltaX,deltaY);
	}
	
	void _MoveCallback(int deltaX,int deltaY)
	{
		OnMove(deltaX,deltaY);
		for(uint i=0;i<_Children.length();i++)
		_Children[i]._MoveCallback(deltaX,deltaY);
	}
	
	bool _IsHitch()
	{
		bool result=(!_IsDraggable&&cast<GUIPanel>(this)!is null&&cast<GUIButton>(this)is null&&cast<GUIGrid>(this)is null);
		return result&&(Parent!is null?Parent._IsHitch():true);
	}
	
	GUIObject@FindMouseHit()
	{
		return FindHit(__MouseX,__MouseY);
	}
	
	GUIObject@FindHit(int x,int y)
	{
		
		for(int i=int(_Children.length())-1;i>=0;i--)
		{
			GUIObject@obj=_Children[i].FindHit(x,y);
			if(obj!is null)
			return obj;
		} 
		
		if(IsHit(x,y))
		return this; 
		
		return null;
	}
	
	bool IsMouseHit()
	{
		return IsHit(__MouseX,__MouseY);
	}
	
	bool IsHit(int x,int y)
	{
		return Active&&!_IsNotHittable&&_Width>0&&_Height>0&&((x)>=(_AbsolutePosX)&&(x)<(_AbsolutePosX)+(_Width)&&(y)>=(_AbsolutePosY)&&(y)<(_AbsolutePosY)+(_Height));
	}
	
	void _GetWholeSizeRect(int[]&rect)
	{
		int l=_AbsolutePosX;
		int t=_AbsolutePosY;
		int r=l+Width;
		int b=t+Height;
		
		if(l<rect[0])
		rect[0]=l;
		if(t<rect[1])
		rect[1]=t;
		if(r>rect[2])
		rect[2]=r;
		if(b>rect[3])
		rect[3]=b;
		
		for(uint i=0;i<_Children.length();i++)
		_Children[i]._GetWholeSizeRect(rect);
	}
	
	void GetWholeSize(int&centerX,int&centerY,int&wholeWidth,int&wholeHeight)
	{
		int[]rect={1000000000,1000000000,-1000000000,-1000000000};
		_GetWholeSizeRect(rect);
		wholeWidth=rect[2]-rect[0];
		wholeHeight=rect[3]-rect[1];
		centerX=rect[0]+wholeWidth/2;
		centerY=rect[1]+wholeHeight/2;
	}
	
	void _MouseDown(int button)
	{
		_IsPressed=true;
		_PressedButton=button;
		_PressedX=__MouseX;
		_PressedY=__MouseY;
		OnMouseDown(button);
		
		if(_IsDraggable&&_PressedButton==(0))
		{
			bool draggableCursor=(GetCurrentCursor()==(6));
			if(draggableCursor)
			{
				_IsDragged=true;
				OnDragChanged();
			}
		}
		
		if(!_DeferredMousePressed)
		{
			Screen._GlobalMousePressed(button);
			_MousePressed(button);
		}
		_PressedRepeatTime=GetTick()+500;
	}
	
	void _MousePressed(int button)
	{
		OnMousePressed(button);
		if(button==(0))
		OnLMousePressed();
		else if(button==(1))
		OnRMousePressed();
		_PressedRepeatTime=GetTick()+40;
	}
	
	void _MouseUp(bool lost)
	{
		_IsPressed=false;
		
		if(_DeferredMousePressed)
		{
			Screen._GlobalMousePressed(_PressedButton);
			_MousePressed(_PressedButton);
		}
		
		OnMouseUp(_PressedButton,lost);
		
		if(_IsDragged)
		{
			_IsDragged=false;
			OnDragChanged();
		}
	}
	
	void MouseClick(int button)
	{
		OnMouseClick(button);
		if(button==(0))
		OnLMouseClick();
		else if(button==(1))
		OnRMouseClick();
	}
	
	void _MouseMove()
	{
		OnMouseMove();
	}
	
	void _GlobalMouseDown(int button)
	{
		OnGlobalMouseDown(button);
		for(uint i=0;i<_Children.length();i++)
		_Children[i]._GlobalMouseDown(button);
	}
	
	void _GlobalMouseUp(int button)
	{
		OnGlobalMouseUp(button);
		for(uint i=0;i<_Children.length();i++)
		_Children[i]._GlobalMouseUp(button);
	}
	
	void _GlobalMousePressed(int button)
	{
		OnGlobalMousePressed(button);
		for(uint i=0;i<_Children.length();i++)
		_Children[i]._GlobalMousePressed(button);
	}
	
	void _GlobalMouseClick(int button)
	{
		OnGlobalMouseClick(button);
		for(uint i=0;i<_Children.length();i++)
		_Children[i]._GlobalMouseClick(button);
	}
	
	void _GlobalMouseMove()
	{
		OnGlobalMouseMove();
		for(uint i=0;i<_Children.length();i++)
		_Children[i]._GlobalMouseMove();
	}
	
	void Input(uint8 key,string@text)
	{
		OnInput();
		if(text is null)
		OnInput(key);
		else
		OnInput(text);
		OnInput(key,text);
	}
	
	void _GlobalInput(uint8 key,string@text)
	{
		OnGlobalInput(key,text);
		for(uint i=0;i<_Children.length();i++)
		_Children[i]._GlobalInput(key,text);
	}
	
	void _Focus()
	{
		if(!_IsFocused)
		{
			_IsFocused=true;
			OnFocusChanged();
		}
	}
	
	void _Unfocus()
	{
		if(_IsFocused)
		{
			_IsFocused=false;
			OnFocusChanged();
		}
	}
	
	void _Hover()
	{
		if(!_IsHovered)
		{
			_IsHovered=true;
			OnHoverChanged();
		}
	}
	
	void _Unhover()
	{
		if(_IsHovered)
		{
			_IsHovered=false;
			OnHoverChanged();
		}
	}
	
	GUIObject@_Clone(GUIObject@parent=null)
	{
		GUIObject@newObject=_CloneExt(parent);
		newObject._Init();
		return@newObject;
	}
	
	GUIObject@_CloneExt(GUIObject@parent)
	{
		GUIObject@newObject;
		reflection::typeof<GUIObject>(this).instantiate(@this,@newObject);
		newObject._Children.resize(0);
		@newObject._Parent=parent;
		if(parent!is null)
		parent._Children.insertLast(newObject);
		newObject.OnConstruct();
		for(uint i=0;i<_Children.length();i++)
		_Children[i]._CloneExt(newObject);
		return@newObject;
	}
	
	GUIPanel@FindPanel(string&name)
	{
		return cast<GUIPanel>(Find(name));
	}
	
	GUIText@FindText(string&name)
	{
		return cast<GUIText>(Find(name));
	}
	
	GUITextInput@FindTextInput(string&name)
	{
		return cast<GUITextInput>(Find(name));
	}
	
	GUIButton@FindButton(string&name)
	{
		return cast<GUIButton>(Find(name));
	}
	
	GUIObject@Find(string&name,bool deepFind=true)
	{
		for(uint i=0;i<_Children.length();i++)
		{
			GUIObject@child=_Children[i];
			if(child._Name!is null&&child._Name==name)
			return child;
			
			if(deepFind)
			{
				GUIObject@obj=child.Find(name);
				if(obj!is null)
				return obj;
			}
		}
		return null;
	}
	
	GUIObject@GetChild(uint index)
	{
		return _Children[index];
	}
	
	void _RefreshPosition()
	{
		
		_Width=_BaseWidth;
		_Height=_BaseHeight;
		int parentAbsolutePosX=(_Parent!is null?_Parent._AbsolutePosX:0);
		int parentAbsolutePosY=(_Parent!is null?_Parent._AbsolutePosY:0);
		int parentWidth=(_Parent!is null?_Parent._Width:__ScreenWidth);
		int parentHeight=(_Parent!is null?_Parent._Height:__ScreenHeight);
		int parentBaseWidth=(_Parent!is null?_Parent._BaseWidth:_BaseWidth);
		int parentBaseHeight=(_Parent!is null?_Parent._BaseHeight:_BaseHeight); 
		
		int newPosX;
		int newPosY;
		if(_Dock!=0)
		{
			if(_Dock==(1))
			{
				newPosX=parentAbsolutePosX;
				newPosY=parentAbsolutePosY;
				_Height=parentHeight;
			}
			else if(_Dock==(2))
			{
				newPosX=parentAbsolutePosX+parentWidth-_Width;
				newPosY=parentAbsolutePosY;
				_Height=parentHeight;
			}
			else if(_Dock==(3))
			{
				newPosX=parentAbsolutePosX;
				newPosY=parentAbsolutePosY;
				_Width=parentWidth;
			}
			else if(_Dock==(4))
			{
				newPosX=parentAbsolutePosX;
				newPosY=parentAbsolutePosY+parentHeight-_Height;
				_Width=parentWidth;
			}
			else if(_Dock==(5))
			{
				newPosX=parentAbsolutePosX;
				newPosY=parentAbsolutePosY;
				_Width=parentWidth;
				_Height=parentHeight;
			}
			else
			{
				newPosX=_BasePosX+parentAbsolutePosX;
				newPosY=_BasePosY+parentAbsolutePosY;
			}
		}
		
		else
		{
			if((_Anchor&(0x1))!=0)
			newPosX=parentAbsolutePosX+_BasePosX;
			else if((_Anchor&(0x2))!=0)
			newPosX=parentAbsolutePosX+_BasePosX+(parentWidth-parentBaseWidth);
			else
			newPosX=parentAbsolutePosX+_BasePosX+(parentWidth-parentBaseWidth)/2;
			
			if((_Anchor&(0x4))!=0)
			newPosY=parentAbsolutePosY+_BasePosY;
			else if((_Anchor&(0x8))!=0)
			newPosY=parentAbsolutePosY+_BasePosY+(parentHeight-parentBaseHeight);
			else
			newPosY=parentAbsolutePosY+_BasePosY+(parentHeight-parentBaseHeight)/2;
		} 
		
		if(newPosX!=_AbsolutePosX||newPosY!=_AbsolutePosY)
		_Move(newPosX-_AbsolutePosX,newPosY-_AbsolutePosY,false,false);
	}
	
	void _SizeChanged()
	{
		
	} 
	
	void SetName(string@name)
	{
		@_Name=name;
	}
	
	void SetActive(bool active)
	{
		if(_ActiveSelf!=active)
		{
			_ActiveSelf=active;
			_ActiveChanged();
		}
	}
	
	void _ActiveChanged()
	{
		OnActiveChanged();
		for(uint i=0;i<_Children.length();i++)
		_Children[i]._ActiveChanged();
	}
	
	void SetPosition(int x,int y)
	{
		if(_BasePosX==x&&_BasePosY==y)
		return;
		
		_BasePosX=x;
		_BasePosY=y;
		_RefreshPosition();
	}
	
	void SetPosition(string&iniKey)
	{
		
		string@str=GetIfaceIniStr(iniKey);
		if(@str==null||str=="")
		return;
		
		string@[]@valuesStr=splitEx(str," ");
		if(valuesStr.length()!=4)
		return;
		
		int[]values(4);
		for(int i=0;i<4;i++)
		values[i]=valuesStr[i].toInt();
		
		_BasePosX=values[0];
		_BasePosY=values[1];
		_BaseWidth=values[2]-values[0];
		_BaseHeight=values[3]-values[1];
		_RefreshPosition();
	}
	
	void SetSize(int w,int h)
	{
		if(_BaseWidth==w&&_BaseHeight==h)
		return;
		
		_BaseWidth=w;
		_BaseHeight=h;
		_RefreshPosition();
		_SizeChanged();
	}
	
	void SetAnchor(int anchorStyles)
	{
		if(_Anchor==anchorStyles)
		return;
		
		_Anchor=anchorStyles;
		_RefreshPosition();
	}
	
	void SetDock(int dockStyle)
	{
		if(_Dock==dockStyle)
		return;
		
		_Dock=dockStyle;
		_RefreshPosition();
	}
	
	void SetDraggable(bool enabled)
	{
		_IsDraggable=enabled;
	}
	
	void SetNotHittable(bool enabled)
	{
		_IsNotHittable=enabled;
	}
	
	void SetCheckTransparentOnHit(bool enabled)
	{
		_CheckTransparentOnHit=enabled;
	}
	
	void SetDeferredMousePressed(bool enabled)
	{
		_DeferredMousePressed=enabled;
	}
}

shared class GUIPanel:GUIObject
{
	Sprite@get_BackgroundImage()final{return _BackgroundImage;}
	int get_BackgroundImageLayout()final{return _BackgroundImage!is null?_BackgroundImage.Layout:(0);}
	
	Sprite@_BackgroundImage;
	
	bool IsHit(int x,int y)override
	{
		if(GUIObject::IsHit(x,y))
		{
			if(_CheckTransparentOnHit&&_BackgroundImage!is null)
			return(GetPixelColor(_BackgroundImage.Id,_BackgroundImage.Frame,x-_AbsolutePosX,y-_AbsolutePosY)&0xFF000000)!=0;
			return true;
		}
		return false;
	}
	
	void _Draw(bool callCallback)override
	{
		if(callCallback)
		_DrawCallback(); 
		
		if(_BackgroundImage!is null)
		_DrawImage(_BackgroundImage);
		
		GUIObject::_Draw(false);
	}
	
	void _DrawImage(Sprite@image)
	{
		if(_Width>0&&_Height>0)
		image.Draw(_AbsolutePosX,_AbsolutePosY,_Width,_Height);
	}
	
	void SetBackgroundImage(string@imageName,int imageLayout=(0))
	{
		_SetImage(_BackgroundImage,imageName,imageLayout);
	}
	
	void SetBackgroundImage(uint imageNameHash,int imageLayout=(0))
	{
		_SetImage(_BackgroundImage,imageNameHash,imageLayout);
	}
	
	void _SetImage(Sprite@&curImage,string@imageName,int imageLayout)
	{
		@curImage=null;
		if(imageName!is null)
		{
			Sprite spr;
			spr.Load(imageName,(findFirst(imageName,"/")!=-1||findFirst(imageName,"\\")!=-1)?(0):(4));
			if(spr.Id!=0)
			@curImage=spr;
		}
		
		if(curImage!is null)
		curImage.Layout=imageLayout;
		
		if(curImage!is null&&(imageLayout==(0)||(_BaseWidth==0&&_BaseHeight==0)))
		SetSize(curImage.Width,curImage.Height);
	}
	
	void _SetImage(Sprite@&curImage,uint imageNameHash,int imageLayout)
	{
		if(curImage!is null&&curImage.LoadedNameHash==imageNameHash)
		return;
		
		@curImage=null;
		if(imageNameHash!=0)
		{
			Sprite spr;
			spr.Load(imageNameHash);
			if(spr.Id!=0)
			@curImage=spr;
		}
		
		if(curImage!is null)
		curImage.Layout=imageLayout;
		
		if(curImage!is null&&(imageLayout==(0)||(_BaseWidth==0&&_BaseHeight==0)))
		SetSize(curImage.Width,curImage.Height);
	}
}

shared class GUIText:GUIObject
{
	string@get_Text(){return _Text;}
	int get_TextFont()final{return _TextFont;}
	uint get_TextColor()final{return _TextColor;}
	uint get_TextColorFocused()final{return _TextColorFocused;}
	int get_TextFlags()final{return _TextFlags;}
	
	string _Text;
	int _TextFont=((5));
	uint _TextColor=((uint((0xFF<<24)|(((60)&0xFF)<<16)|(((248)&0xFF)<<8)|((0)&0xFF))));
	uint _TextColorFocused;
	int _TextFlags;
	
	void _Draw(bool callCallback)override
	{
		if(callCallback)
		_DrawCallback(); 
		
		string@text=Text;
		if(text.length()>0)
		{
			uint color=(_IsFocused&&_TextColorFocused!=0?_TextColorFocused:_TextColor);
			DrawText(text,_AbsolutePosX,_AbsolutePosY,_Width,_Height,color,_TextFont,_TextFlags);
		}
		
		GUIObject::_Draw(false);
	}
	
	void SetText(string@text,int font,int flags)
	{
		if(text!is null)
		_Text=text;
		else
		_Text="";
		
		_TextFont=font;
		_TextFlags=flags;
	}
	
	void SetText(string@text)
	{
		if(text!is null)
		_Text=text;
		else
		_Text="";
	}
	
	void SetTextFont(int font)
	{
		_TextFont=font;
	}
	
	void SetTextFlags(int flags)
	{
		_TextFlags=flags;
	}
	
	void SetTextColor(uint color)
	{
		_TextColor=color;
	}
	
	void SetTextFocusedColor(uint color)
	{
		_TextColorFocused=color;
	}
} 

shared class GUITextInput:GUIText
{
	uint get_InputLength()final{return _InputLength;}
	bool get_IsTextPassword()final{return _IsTextPassword;}
	string get_PasswordChar()final{return _PasswordChar;}
	
	uint _InputLength;
	bool _IsTextPassword;
	string _PasswordChar;
	uint _PasswordTime;
	int _CarriagePos;
	
	void _Construct()override
	{
		SetCarriage(false);
		_TextColorFocused=((uint((0xFF<<24)|(((0)&0xFF)<<16)|(((0xAA)&0xFF)<<8)|((0)&0xFF))));
		
		GUIText::_Construct();
	}
	
	void _Draw(bool callCallback)override
	{
		if(callCallback)
		_DrawCallback(); 
		
		string@text=Text;
		if(_IsTextPassword)
		{
			string@rawText=text;
			@text="";
			for(uint i=0;i<rawText.length();i++)
			text+=_PasswordChar;
			if(GetTick()-_PasswordTime<=(1000))
			text[-1]=rawText[-1];
		}
		if(_CarriagePos!=-1&&_IsFocused)
		{
			if(_CarriagePos<0)
			_CarriagePos=0;
			if(_CarriagePos>int(text.length()))
			_CarriagePos=text.length();
			@text=text.substring(0,_CarriagePos)+(GetTick()%800<400?"!":".")+text.substring(_CarriagePos);
		}
		if(text.length()>0)
		{
			uint color=(_IsFocused&&_TextColorFocused!=0?_TextColorFocused:_TextColor);
			DrawText(text,_AbsolutePosX,_AbsolutePosY,_Width,_Height,color,_TextFont,_TextFlags);
		}
		
		GUIObject::_Draw(false);
	}
	
	void Input(uint8 key,string@text)override
	{
		uint oldLen=_Text.length();
		_ProcessKey(key,text,_Text,_CarriagePos);
		while(_InputLength!=0&&_Text.length()>_InputLength)
		_Text[-1]="";
		if(_IsTextPassword)
		_PasswordTime=(_Text.length()>oldLen?GetTick():0);
		
		GUIText::Input(key,text);
	}
	
	bool _ProcessKey(uint8 key,string@text,string&resultText,int&carriagePos)
	{
		if(carriagePos!=-1)
		{
			if(carriagePos<0)
			carriagePos=0;
			else if(carriagePos>int(resultText.length()))
			carriagePos=resultText.length();
			
			if(key==0x0E)
			{
				if(carriagePos>0)
				{
					resultText[carriagePos-1]="";
					carriagePos--;
				}
			}
			else if(key==0xD3)
			{
				if(carriagePos<int(resultText.length()))
				resultText[carriagePos]="";
			}
			else if(key==0xCD)
			{
				if(carriagePos<int(resultText.length()))
				carriagePos++;
			}
			else if(key==0xCB)
			{
				if(carriagePos>0)
				carriagePos--;
			}
			else if(key==0xC7)
			{
				carriagePos=0;
			}
			else if(key==0xCF)
			{
				carriagePos=resultText.length();
			}
			else if(text!is null)
			{
				resultText=resultText.substring(0,carriagePos)+text+resultText.substring(carriagePos);
				carriagePos+=text.length();
			}
			else
			{
				return false;
			}
		}
		else
		{
			if(key==0x0E)
			{
				if(resultText.length()>0)
				resultText[-1]="";
			}
			else if(text!is null)
			{
				resultText+=text;
			}
			else
			{
				return false;
			}
		}
		return true;
	}
	
	void SetInputLength(uint length)
	{
		_InputLength=length;
	}
	
	void SetInputPassword(string@passwordChar)
	{
		_IsTextPassword=(@passwordChar!=null&&passwordChar.length()==1);
		_PasswordChar=passwordChar;
		_PasswordTime=0;
	}
	
	void SetCarriage(bool enable)
	{
		_CarriagePos=(enable?int(_Text.length()):-1);
	}
}

shared class GUIButton:GUIPanel
{
	bool get_IsDisabled()final{return _IsDisabled;}
	bool get_IsSwitched()final{return _IsSwitched;}
	Sprite@get_PressedImage()final{return _PressedImage;}
	int get_PressedImageLayout()final{return _PressedImage!is null?_PressedImage.Layout:(0);}
	Sprite@get_HoverImage()final{return _HoverImage;}
	int get_HoverImageLayout()final{return _HoverImage!is null?_HoverImage.Layout:(0);}
	Sprite@get_DisabledImage()final{return _DisabledImage;}
	int get_DisabledImageLayout()final{return _DisabledImage!is null?_DisabledImage.Layout:(0);}
	
	bool _IsDisabled;
	bool _IsSwitched;
	Sprite@_PressedImage;
	Sprite@_HoverImage;
	Sprite@_DisabledImage;
	
	void _Construct()override
	{
		_DeferredMousePressed=true;
		
		GUIPanel::_Construct();
	}
	
	void _Draw(bool callCallback)override
	{
		if(callCallback)
		_DrawCallback();
		
		if(!_IsDisabled)
		{
			
			bool isPressed=((_IsPressed&&_PressedButton==(0))||_IsSwitched);
			if(isPressed&&_PressedImage!is null)
			_DrawImage(_PressedImage);
			
			else if(_IsHovered&&_HoverImage!is null)
			_DrawImage(_HoverImage);
			
			else if(_BackgroundImage!is null)
			_DrawImage(_BackgroundImage);
		}
		else
		{
			
			if(_DisabledImage!is null)
			_DrawImage(_DisabledImage);
			
			else if(_BackgroundImage!is null)
			_DrawImage(_BackgroundImage);
		}
		
		GUIObject::_Draw(false);
	}
	
	void MouseClick(int button)
	{
		if(_IsDisabled)
		return;
		
		GUIPanel::MouseClick(button);
	}
	
	void _MousePressed(int button)
	{
		if(_IsDisabled)
		return;
		
		GUIPanel::_MousePressed(button);
	}
	
	void SetPressedImage(string@imageName,int imageLayout=(0))
	{
		_SetImage(_PressedImage,imageName,imageLayout);
	}
	
	void SetPressedImage(uint imageNameHash,int imageLayout=(0))
	{
		_SetImage(_PressedImage,imageNameHash,imageLayout);
	}
	
	void SetHoverImage(string@imageName,int imageLayout=(0))
	{
		_SetImage(_HoverImage,imageName,imageLayout);
	}
	
	void SetHoverImage(uint imageNameHash,int imageLayout=(0))
	{
		_SetImage(_HoverImage,imageNameHash,imageLayout);
	}
	
	void SetDisabledImage(string@imageName,int imageLayout=(0))
	{
		_SetImage(_DisabledImage,imageName,imageLayout);
	}
	
	void SetDisabledImage(uint imageNameHash,int imageLayout=(0))
	{
		_SetImage(_DisabledImage,imageNameHash,imageLayout);
	}
	
	void SetSwitch(bool enabled)
	{
		_IsSwitched=enabled;
	}
	
	void SetCondition(bool enabled)
	{
		_IsDisabled=!enabled;
	}
}

shared class GUICheckBox:GUIButton
{
	bool get_IsChecked()final{return _IsSwitched;} 
	
	void OnCheckedChanged(){}
	
	void MouseClick(int button)
	{
		if(_IsDisabled)
		return;
		
		if(button==(0))
		SetChecked(!_IsSwitched);
		
		GUIPanel::MouseClick(button);
	}
	
	void SetChecked(bool checked)
	{
		if(_IsSwitched!=checked)
		{
			_IsSwitched=checked;
			OnCheckedChanged();
		}
	}
}

shared class GUIRadioButton:GUICheckBox
{
	void MouseClick(int button)
	{
		if(_IsDisabled||_IsSwitched)
		return;
		
		if(button==(0))
		SetChecked(true);
		
		GUIPanel::MouseClick(button);
	}
	
	void SetChecked(bool checked)override
	{
		if(checked&&_Parent!is null)
		{
			for(uint i=0;i<_Parent._Children.length();i++)
			{
				GUIRadioButton@button=cast<GUIRadioButton>(_Parent._Children[i]);
				if(button!is null&&button._IsSwitched)
				{
					button._IsSwitched=false;
					button.OnCheckedChanged();
				}
			}
		}
		
		if(_IsSwitched!=checked)
		{
			_IsSwitched=checked;
			OnCheckedChanged();
		}
	}
}

shared class GUIScreen:GUIPanel
{
	int get_Index()final{return _Index;}
	bool get_IsHardcoded()final{return _IsHardcoded;}
	bool get_IsMain()final{return((_Index)>=(1)&&(_Index)<=(7));}
	bool get_IsModal()final{return _IsModal;}
	bool get_IsMultiinstance()final{return _IsMultiinstance;}
	bool get_IsCloseOnMiss()final{return _IsCloseOnMiss;}
	int[]get_AvailableCursors()final{return _AvailableCursors;}
	int get_Cursor()final{return _Cursor;}
	bool get_IsCanMove()final{return _IsCanMove;}
	bool get_IsMoveIgnoreBorders()final{return _IsMoveIgnoreBorders;}
	
	int _Index;
	bool _IsHardcoded;
	bool _IsRegistered;
	bool _IsModal;
	bool _IsMultiinstance;
	bool _IsCloseOnMiss;
	int[]_AvailableCursors;
	int _Cursor;
	bool _IsCanMove;
	bool _IsMoveIgnoreBorders; 
	
	bool[]@_InputKeyPressed;
	bool[]@_InputMousePressed;
	
	void _Show(dictionary@params)override
	{
		
		_ActiveSelf=true; 
		
		_Cursor=(_AvailableCursors.length()>0?AvailableCursors[0]:(0)); 
		
		GUIPanel::_Show(params);
	}
	
	void _Hide()override
	{
		
		_ActiveSelf=false; 
		
		GUIPanel::_Hide();
	}
	
	void _Appear(dictionary@params)override
	{
		
		ChangeCursor(_Cursor); 
		
		GUIPanel::_Appear(params);
	}
	
	void _Disappear()override
	{
		
		_Cursor=GetCurrentCursor(); 
		
		GUIPanel::_Disappear();
	}
	
	void _GlobalMouseClick(int button)override
	{
		if(button==(1))
		{
			if(_AvailableCursors.length()>0)
			{
				int curCursor=GetCurrentCursor();
				int curCursorIndex=_AvailableCursors.find(curCursor);
				if(curCursorIndex!=-1)
				{
					curCursorIndex++;
					if(curCursorIndex>=int(_AvailableCursors.length()))
					curCursorIndex=0;
					ChangeCursor(_AvailableCursors[curCursorIndex]);
				}
			}
		}
		else
		{
			GUIPanel::_GlobalMouseClick(button);
		}
	}
	
	void _GlobalMouseMove()override
	{
		
		if(_IsCanMove)
		{
			GUIObject@pressedObj=_FindPressed(this);
			if(pressedObj!is null&&pressedObj._PressedButton==(0)&&pressedObj._IsHitch())
			{
				int lastPosX=_AbsolutePosX;
				int lastPosY=_AbsolutePosY;
				int newPosX=_AbsolutePosX+(__MouseX-pressedObj._PressedX);
				int newPosY=_AbsolutePosY+(__MouseY-pressedObj._PressedY);
				pressedObj._PressedX=__MouseX;
				pressedObj._PressedY=__MouseY; 
				
				if(!_IsMoveIgnoreBorders)
				{
					int parentAbsolutePosX=(_Parent!is null?_Parent._AbsolutePosX:0);
					int parentAbsolutePosY=(_Parent!is null?_Parent._AbsolutePosY:0);
					int parentWidth=(_Parent!is null?_Parent._Width:__ScreenWidth);
					int parentHeight=(_Parent!is null?_Parent._Height:__ScreenHeight);
					int px=newPosX;
					int py=newPosY;
					if(newPosX<parentAbsolutePosX)
					newPosX=parentAbsolutePosX;
					if(newPosY<parentAbsolutePosY)
					newPosY=parentAbsolutePosY;
					if(newPosX+_Width>parentWidth)
					newPosX=parentWidth-_Width;
					if(newPosY+_Height>parentHeight)
					newPosY=parentHeight-_Height;
					pressedObj._PressedX+=newPosX-px;
					pressedObj._PressedY+=newPosY-py;
				} 
				
				if(lastPosX!=newPosX||lastPosY!=newPosY)
				{
					int deltaX=newPosX-lastPosX;
					int deltaY=newPosY-lastPosY;
					_Move(deltaX,deltaY,true,true);
				}
			}
		}
		
		GUIPanel::_GlobalMouseMove();
	}
	
	GUIObject@_FindPressed(GUIObject@obj)
	{
		if(obj._IsPressed)
		return obj;
		for(uint i=0;i<obj._Children.length();i++)
		{
			GUIObject@pressedObj=_FindPressed(obj._Children[i]);
			if(pressedObj!is null)
			return pressedObj;
		}
		return null;
	} 
	
	void SetModal(bool enabled)
	{
		_IsModal=enabled;
	}
	
	void SetMultiinstance(bool enabled)
	{
		_IsMultiinstance=enabled;
	}
	
	void SetCloseOnMiss(bool enabled)
	{
		_IsCloseOnMiss=enabled;
	}
	
	void SetAvailableCursors(int[]cursors)
	{
		_AvailableCursors=cursors;
	}
	
	void SetCanMove(bool enabled,bool ignoreBorders)
	{
		_IsCanMove=enabled;
		_IsMoveIgnoreBorders=ignoreBorders;
	}
}

shared class GUIGrid:GUIPanel
{
	string@get_CellPrototype()final{return _CellPrototype;}
	uint get_GridSize()final{return _GridSize;}
	int get_Columns()final{return _Columns;}
	int get_PaddingX()final{return _PaddingX;}
	int get_PaddingY()final{return _PaddingY;}
	GUIObject@[]get_Cells()final{return _Cells;}
	
	string@_CellPrototype;
	uint _GridSize;
	int _Columns;
	int _PaddingX;
	int _PaddingY;
	GUIObject@[]_Cells;
	
	void _Init()override
	{
		if(_CellPrototype!is null)
		SetCellPrototype(_CellPrototype);
		
		if(_GridSize>0)
		ResizeGrid(_GridSize);
		
		GUIPanel::_Init();
	}
	
	void ResizeGrid(uint size)
	{
		
		if(_CellPrototype is null||_CellPrototype.length()==0)
		return;
		GUIObject@cellPrototype=(_CellPrototype[0]!="."?Find(_CellPrototype):Parent.Find(_CellPrototype.substring(1),false));
		if(cellPrototype is null)
		return; 
		
		int childIndex=-1;
		if(cellPrototype._Parent is this)
		childIndex=cellPrototype._Parent._Children.findByRef(cellPrototype); 
		
		for(uint i=0;i<_Children.length();)
		{
			if(_Cells.findByRef(_Children[i])!=-1)
			_Children.removeAt(i);
			else
			i++;
		}
		_Cells.resize(0); 
		
		cellPrototype._ActiveSelf=true;
		GUIObject@[]cellInstances;
		int col=0,row=0;
		for(uint i=0;i<size;i++)
		{
			GUIObject@cellInstance=cellPrototype._CloneExt(this);
			_Children.removeLast();
			_Children.insertAt(++childIndex,cellInstance);
			_Cells.insertLast(cellInstance);
			_SetCellIndex(cellInstance,this,cellInstances.length());
			cellInstances.insertLast(cellInstance);
			cellInstance._Move(col*(cellInstance._Width+_PaddingX),row*(cellInstance._Height+_PaddingY),false,true);
			
			if(++col>=_Columns)
			{
				col=0;
				row++;
			}
		}
		cellPrototype._ActiveSelf=false; 
		
		for(uint i=0;i<cellInstances.length();i++)
		{
			OnResizeGrid(cellInstances[i],i);
			_ResizeGrid(cellInstances[i],cellInstances[i],i);
		} 
		
		for(uint i=0;i<cellInstances.length();i++)
		cellInstances[i]._Init();
	}
	
	void _SetCellIndex(GUIObject@obj,GUIGrid@grid,uint cellIndex)
	{
		@obj._Grid=grid;
		obj._CellIndex=cellIndex;
		
		for(uint i=0;i<obj._Children.length();i++)
		_SetCellIndex(obj._Children[i],grid,cellIndex);
	}
	
	void _ResizeGrid(GUIObject@obj,GUIObject@cell,uint cellIndex)
	{
		obj.OnResizeGrid(cell,cellIndex);
		
		for(uint i=0;i<obj._Children.length();i++)
		_ResizeGrid(obj._Children[i],cell,cellIndex);
	}
	
	void SetCellPrototype(string name)
	{
		@_CellPrototype=name;
		if(_CellPrototype!is null&&_CellPrototype.length()>0)
		{
			GUIObject@cellPrototype=(_CellPrototype[0]!="."?Find(_CellPrototype):Parent.Find(_CellPrototype.substring(1),false));
			if(cellPrototype!is null)
			cellPrototype._ActiveSelf=false;
		}
	}
	
	void SetGridSize(uint size)
	{
		_GridSize=size;
	}
	
	void SetColumns(int length)
	{
		_Columns=length;
	}
	
	void SetPadding(int x,int y)
	{
		_PaddingX=x;
		_PaddingY=y;
	}
}

shared class GUIMessageBox:GUIText
{
	string[]get_MessageTexts()final{return _MessageTexts;}
	int[]get_MessageTypes()final{return _MessageTypes;}
	string[]get_MessageTimes()final{return _MessageTimes;}
	bool[]get_DisplayedMessages()final{return _DisplayedMessages;}
	bool get_InvertMessages()final{return _InvertMessages;}
	
	string[]_MessageTexts;
	int[]_MessageTypes;
	string[]_MessageTimes;
	bool[]_DisplayedMessages;
	bool _InvertMessages;
	int _Scroll;
	int _MaxScroll;
	int _ScrollLines;
	Sprite _ScrollUp;
	Sprite _ScrollDown;
	
	void _Construct()override
	{
		_DisplayedMessages=array<bool>((10),true);
		
		_ScrollUp.Load("SUPARROW.FRM",(4));
		_ScrollDown.Load("SDNARROW.FRM",(4));
		
		GUIText::_Construct();
	}
	
	void _Show(dictionary@params)override
	{
		GUIText::_Show(params);
		
		_InvertMessages=__MsgboxInvert;
		_GenerateText();
	}
	
	void _Draw(bool callCallback)override
	{
		if(!_InvertMessages)
		_TextFlags=(0x0040)|(0x0020)|(0x0800|((_ScrollLines)<<16));
		else
		_TextFlags=(0x0400|((_ScrollLines)<<16));
		
		GUIText::_Draw(callCallback);
		
		if(_IsHovered)
		{
			Sprite@spr=(__MouseY<_AbsolutePosY+_Height/2?_ScrollUp:_ScrollDown);
			spr.Draw(__MouseX-spr.Width/2,__MouseY-spr.Height/2);
		}
	}
	
	void _Remove()override
	{
		__HideCursor=false;
		
		GUIText::_Remove();
	}
	
	void _Hover()override
	{
		GUIText::_Hover();
		
		__HideCursor=true;
	}
	
	void _Unhover()override
	{
		GUIText::_Unhover();
		
		__HideCursor=false;
	}
	
	void _SizeChanged()override
	{
		_GenerateText();
		
		GUIText::_SizeChanged();
	}
	
	void _MousePressed(int button)override
	{
		if(button==(0)||button==(3)||button==(4))
		{
			if(button==(3)||(button==(0)&&__MouseY<_AbsolutePosY+_Height/2))
			{
				if(_InvertMessages&&_Scroll>0)
				_Scroll--;
				if(!_InvertMessages&&_Scroll<_MaxScroll)
				_Scroll++;
			}
			else if(button==(4)||(button==(0)&&__MouseY>=_AbsolutePosY+_Height/2))
			{
				if(_InvertMessages&&_Scroll<_MaxScroll)
				_Scroll++;
				if(!_InvertMessages&&_Scroll>0)
				_Scroll--;
			}
			_GenerateText();
		}
		
		GUIText::_MousePressed(button);
	}
	
	void AddMessage(string@text,int type=(0))
	{
		
		if(type==(0)&&text=="error")
		return; 
		
		string messageText;
		if(type>=(0)&&type<=(3))
		{
			uint[]sayColors={((uint((0xFF<<24)|(((0)&0xFF)<<16)|(((0xAA)&0xFF)<<8)|((0)&0xFF)))),((uint((0xFF<<24)|(((60)&0xFF)<<16)|(((248)&0xFF)<<8)|((0)&0xFF)))),((uint((0xFF<<24)|(((0xAA)&0xFF)<<16)|(((0)&0xFF)<<8)|((0)&0xFF)))),((uint((0xFF<<24)|(((0)&0xFF)<<16)|(((0x66)&0xFF)<<8)|((0)&0xFF))))};
			messageText="|"+sayColors[type]+" "+EncodeUTF8((0x2022))+" |"+((uint((0xFF<<24)|(((60)&0xFF)<<16)|(((248)&0xFF)<<8)|((0)&0xFF))))+" "+text;
		}
		else
		{
			messageText=text;
		}
		_MessageTexts.insertLast(messageText); 
		
		int messageType=type;
		_MessageTypes.insertLast(messageType); 
		
		uint16 year=0;
		uint16 month=0;
		uint16 day=0;
		uint16 dayOfWeek=0;
		uint16 hour=0;
		uint16 minute=0;
		uint16 second=0;
		uint16 milliseconds;
		GetTime(year,month,day,dayOfWeek,hour,minute,second,milliseconds);
		string messageTime=(hour<=9?"0":"")+hour+":"+(minute<=9?"0":"")+minute+":"+(second<=9?"0":"")+second+" ";
		_MessageTimes.insertLast(messageTime); 
		
		if(_DisplayedMessages[type])
		{
			if(_Scroll>0&&_IsHovered)
			_Scroll++;
			else
			_Scroll=0;
		}
		_GenerateText();
	}
	
	void _GenerateText()
	{
		if(!Active)
		return;
		
		_Text="";
		if(_MessageTexts.length()==0)
		return;
		
		int tw=0,th=0;
		int maxLines=0;
		GetTextInfo(null,_Width,_Height,_TextFont,0,tw,th,maxLines);
		if(maxLines<=0)
		{
			_MaxScroll=0;
			_ScrollLines=0;
			return;
		}
		
		_ScrollLines=-1;
		int lines=0;
		for(int i=_MessageTexts.length()-1;i>=0;i--)
		{
			string@messageText=_MessageTexts[i];
			int messageType=_MessageTypes[i];
			string@messageTime=_MessageTimes[i]; 
			
			if(!_DisplayedMessages[messageType])
			continue; 
			
			int curLines=lines;
			int skipLines=0;
			GetTextInfo(messageText,_Width,1000,_TextFont,0,tw,th,skipLines);
			lines+=skipLines;
			
			if(_ScrollLines<0)
			{
				if(lines<=_Scroll)
				continue;
				_ScrollLines=_Scroll-curLines;
			}
			
			if(curLines-_Scroll<maxLines)
			{
				
				if(_InvertMessages)
				_Text+=messageText+"\n";
				else
				_Text=messageText+"\n"+_Text;
			}
			else
			{
				break;
			}
		}
		_MaxScroll=lines-maxLines;
		if(_ScrollLines<0)
		_ScrollLines=0;
	}
	
	bool _SetDisplayedMessage(int messageType,bool enable)
	{
		bool generateText=false;
		
		if(messageType!=(10))
		{
			if(_DisplayedMessages[messageType]!=enable)
			{
				_DisplayedMessages[messageType]=enable;
				generateText=true;
			}
		}
		else
		{
			for(uint i=0;i<(10);i++)
			{
				if(_DisplayedMessages[messageType]!=enable)
				{
					_DisplayedMessages[messageType]=enable;
					generateText=true;
				}
			}
		}
		
		return generateText;
	}
	
	void SetDisplayedMessages(int[]messageTypes)
	{
		bool generateText=false;
		bool displayAll=(messageTypes.find((10))!=-1);
		for(uint i=0;i<_DisplayedMessages.length();i++)
		if(_SetDisplayedMessage(i,displayAll||messageTypes.find(i)!=-1))
		generateText=true;
		if(generateText)
		_GenerateText();
	}
	
	void ChangeDisplayedMessage(int messageType,bool enable)
	{
		if(_SetDisplayedMessage(messageType,enable))
		_GenerateText();
	}
	
	void SetInvertMessages(bool invert)
	{
		_InvertMessages=invert;
		_GenerateText();
	}
} 

shared class GUIConsole:GUITextInput
{
	string get_HistoryStorageName()final{return _HistoryStorageName;}
	string[]@get_History()final{
		return _History;
	}
	uint get_HistoryMaxLength()final{return _HistoryMaxLength;}
	
	string@_HistoryStorageName;
	string _HistoryActualStorageName;
	string[]_History;
	uint _HistoryMaxLength;
	uint _HistoryCur;
	
	void _Construct()override
	{
		SetCarriage(true);
		@_HistoryStorageName="";
		
		GUITextInput::_Construct();
	}
	
	void Toggle()
	{
		if(!Active)
		{
			
			Activate();
		}
		else if(_Text.length()==0)
		{
			
			Deactivate();
		}
		else
		{
			
			SendText();
		}
	}
	
	void Activate()
	{
		
		if(Active||!Parent.Active)
		return; 
		
		string actualStorageName="";
		if(_HistoryStorageName!is null&&__Name!is null&&__Name!="")
		actualStorageName="console_"+__Name+_HistoryStorageName;
		
		if(_HistoryActualStorageName!=actualStorageName)
		{
			_History.resize(0);
			_HistoryActualStorageName=actualStorageName;
			if(_HistoryActualStorageName!="")
			{
				Serializator data;
				if(data.Load(_HistoryActualStorageName))
				data.Get(_History);
			}
		}
		
		_HistoryCur=_History.length(); 
		
		SetActive(true);
	}
	
	void Deactivate()
	{
		
		if(_ActiveSelf)
		SetActive(false);
	}
	
	void SendText()
	{
		if(!Active)
		return; 
		
		_History.insertLast(_Text);
		for(uint i=0;i<_History.length()-1;)
		{
			if(_History[i]==_History.last())
			_History.removeAt(i);
			else
			i++;
		} 
		
		uint historyMaxLength=(_HistoryMaxLength!=0?_HistoryMaxLength:__ConsoleHistorySize);
		while(_History.length()>historyMaxLength)
		_History.removeAt(0);
		_HistoryCur=_History.length(); 
		
		if(_HistoryActualStorageName!="")
		{
			Serializator data;
			data.Set(_History);
			data.Save(_HistoryActualStorageName);
		} 
		
		bool[]@keyPressed=Screen._InputKeyPressed;
		if(keyPressed[0x1D]||keyPressed[0x9D])
		CustomCall("ConsoleMessage\n/s"+_Text,"\n");
		else if(keyPressed[0x38]||keyPressed[0xB8])
		CustomCall("ConsoleMessage\n/w"+_Text,"\n");
		else if(keyPressed[0x2A]||keyPressed[0x36])
		CustomCall("ConsoleMessage\n/r"+_Text,"\n");
		else
		CustomCall("ConsoleMessage\n"+_Text,"\n"); 
		
		_Text="";
		_CarriagePos=0;
	}
	
	void _GlobalInput(uint8 key,string@text)override
	{
		GUITextInput::_GlobalInput(key,text);
		
		if(Active)
		{
			if(key==0xC8&&_HistoryCur>0)
			{
				_HistoryCur--;
				_Text=_History[_HistoryCur];
				_CarriagePos=_Text.length();
			}
			else if(key==0xD0)
			{
				if(_HistoryCur+1<_History.length())
				{
					_HistoryCur++;
					_Text=_History[_HistoryCur];
					_CarriagePos=_Text.length();
				}
				else
				{
					_HistoryCur=_History.length();
					_Text="";
					_CarriagePos=0;
				}
				
			}
			else
			{
				GUITextInput::Input(key,text);
			}
		}
		
		if(key==0x1C||key==0x9C)
		{
			Toggle();
		}
	}
	
	void Input(uint8 key,string@text)override
	{
		GUIText::Input(key,text);
	}
	
	void _Draw(bool callCallback)override
	{
		if(callCallback)
		_DrawCallback();
		
		string@text=Text;
		
		if(_CarriagePos<0)
		_CarriagePos=0;
		if(_CarriagePos>int(text.length()))
		_CarriagePos=text.length();
		
		@text=text.substring(0,_CarriagePos)+(GetTick()%800<400?"!":".")+text.substring(_CarriagePos);
		DrawText(text,_AbsolutePosX,_AbsolutePosY,_Width,_Height,_TextColor,_TextFont,_TextFlags);
		
		GUIObject::_Draw(false);
	}
	
	void SetHistoryStorage(string storageName)
	{
		
		_HistoryStorageName=storageName;
	}
	
	void SetHistoryMaxLength(uint length)
	{
		_HistoryMaxLength=length;
	}
}

shared class GUIItemView:GUIGrid
{
	int get_UserData()final{return _UserData;}
	bool get_UseSorting()final{return _UseSorting;}
	uint get_CritterId()final{return _CritterId;}
	ItemCl@[]@get_Items()final{
		return _Items;
	}
	int get_Scroll()final{return _Scroll;}
	
	int _UserData;
	bool _UseSorting;
	uint _CritterId;
	ItemCl@[]_Items;
	int _Scroll; 
	
	int OnCheckItem(ItemCl@item){return-1;}
	void OnScrollChanged(){}
	
	ItemCl@GetItem(uint cellIndex)
	{
		int itemIndex=cellIndex+_Scroll;
		return(itemIndex>=0&&itemIndex<int(_Items.length())?_Items[itemIndex]:null);
	}
	
	void Resort()
	{
		_Resort(); 
		
		int maxScroll=int(_Items.length())-int(_GridSize);
		if(_Columns>0)
		maxScroll+=maxScroll%_Columns;
		if(maxScroll<0)
		maxScroll=0;
		if(_Scroll>maxScroll)
		SetScroll(maxScroll);
	}
	
	void _Resort()
	{
		_Items.resize(0);
		
		CritterCl@cr=(_CritterId==0?GetChosen():GetCritter(_CritterId));
		if(cr!is null)
		{
			ItemCl@[]items;
			cr.GetItems(-1,items);
			if(!_UseSorting)
			{
				for(uint i=0;i<items.length();i++)
				{
					int itemIndex=OnCheckItem(items[i]);
					if(itemIndex>=0)
					{
						if(itemIndex>=int(_Items.length()))
						_Items.resize(itemIndex+1);
						@_Items[itemIndex]=items[i];
					}
				}
			}
			else
			{
				int[]sortValues;
				for(uint i=0;i<items.length();i++)
				{
					int sortValue=OnCheckItem(items[i]);
					if(sortValue>=0)
					{
						bool added=false;
						for(uint j=0;j<_Items.length();j++)
						{
							if(sortValues[j]>sortValue)
							{
								_Items.insertAt(j,items[i]);
								sortValues.insertAt(j,sortValue);
								added=true;
								break;
							}
						}
						if(!added)
						{
							_Items.insertLast(items[i]);
							sortValues.insertLast(sortValue);
						}
					}
				}
			}
		}
	}
	
	void SetUserData(int data)
	{
		_UserData=data;
	}
	
	void SetUseSorting(bool enable)
	{
		_UseSorting=enable;
	}
	
	void SetScroll(int value,bool checkAvailability=false)
	{
		if(checkAvailability&&!CheckScrollAvailability(value))
		return;
		
		_Scroll=value;
		OnScrollChanged();
	}
	
	bool CheckScrollAvailability(int value)
	{
		if(value<_Scroll)
		{
			int minScroll=0;
			return value>=minScroll;
		}
		if(value>_Scroll)
		{
			int maxScroll=int(_Items.length())-int(_GridSize);
			if(_Columns>0)
			maxScroll+=maxScroll%_Columns;
			if(maxScroll<0)
			maxScroll=0;
			return value<=maxScroll;
		}
		return false;
	}
	
	void SetCritter(uint crId)
	{
		_CritterId=crId;
		_Resort();
	}
}   

import void SetChosenTabLevelUp(bool enable)from"chosen_tabs";                                                                                                             

void changedParam_Level(CritterCl&cr,uint,int oldValue)
{
	if(cr.ParamBase[(77)]>oldValue)
	{
		PlaySound("LEVELUP.ACM");
		Message((3),(4090),(0));
		SetChosenTabLevelUp(true);
	}
}

void changedParam_Experience(CritterCl&cr,uint,int oldValue)
{
	int curValue=cr.ParamBase[(76)];
	if(curValue>oldValue)
	Message(ReplaceText(GetMsgStr((3),(4091)),"VALUE",curValue-oldValue),(0));
}

void changedParam_UnspentPerks(CritterCl&cr,uint,int oldValue)
{
	if(cr.ParamBase[(79)]>0&&GUI_GetActiveScreen().Index==(13))
	ShowScreen((32));
}                                               

void CritterGenerate(int[]&params)

{
	if(params[(77)]<=0)
	params[(77)]=1;
	
	if(params[(552)]!=0)
	params[(5)]+=1;
	if(params[(551)]!=0)
	params[(0)]+=2;
	if(params[(560)]!=0)
	{
		params[(206)]+=15;
		params[(207)]+=15;
		params[(214)]+=15;
		params[(215)]+=15;
		params[(200)]-=10;
		params[(201)]-=10;
		params[(202)]-=10;
		params[(203)]-=10;
		params[(204)]-=10;
		params[(205)]-=10;
	}     
	
	params[(200)]+=5+4*params[(5)];
	params[(201)]+=0+2*params[(5)];
	params[(202)]+=0+2*params[(5)];
	params[(203)]+=30+2*(params[(5)]+params[(0)]);
	params[(204)]+=20+2*(params[(5)]+params[(0)]);
	params[(205)]+=0+4*params[(5)];
	params[(206)]+=0+2*(params[(1)]+params[(4)]);
	params[(207)]+=5+params[(1)]+params[(4)];
	params[(208)]+=5+3*params[(5)];
	params[(209)]+=10+params[(1)]+params[(5)];
	params[(210)]+=0+3*params[(5)];
	params[(211)]+=10+params[(1)]+params[(5)];
	params[(212)]+=0+4*params[(4)];
	params[(213)]+=0+3*params[(4)];
	params[(214)]+=0+5*params[(3)];
	params[(215)]+=0+4*params[(3)];
	params[(216)]+=0+5*params[(6)];
	params[(217)]+=0+2*(params[(2)]+params[(4)]);
	
	if(params[(226)]!=0)
	params[params[(226)]]+=20;
	if(params[(227)]!=0)
	params[params[(227)]]+=20;
	if(params[(228)]!=0)
	params[params[(228)]]+=20;
	
	if(params[(550)]!=0)
	{
		params[(30)]-=params[(2)]*2;
		params[(31)]-=params[(2)]*5;
		params[(13)]+=2;
	}
	if(params[(551)]!=0)
	params[(8)]-=2;
	if(params[(555)]!=0)
	{
		params[(9)]-=params[(5)];
		params[(12)]+=5;
	}
	if(params[(556)]!=0)
	params[(10)]+=4;
	if(params[(554)]!=0)
	params[(14)]+=10;
	if(params[(556)]!=0)
	params[(15)]-=30;
	if(params[(557)]!=0)
	params[(538)]=1;  
	
	params[(9)]+=params[(5)];
	params[(7)]+=params[(0)]+params[(2)]*2;
	params[(8)]+=params[(5)]/2;
	params[(11)]+=((25+params[(0)]*(25-params[(552)]*10))*453);
	params[(10)]+=(params[(0)]>6?params[(0)]-5:1);
	params[(31)]+=params[(2)]*5;
	params[(30)]+=params[(2)]*2;
	params[(12)]+=params[(1)]*2;
	params[(13)]+=(((1)>(params[(2)]/3))?(1):(params[(2)]/3));
	params[(14)]+=params[(6)]; 
	
	params[(7)]+=15;
	params[(8)]+=5;
	params[(72)]=params[(7)];
	params[(75)]=params[(8)]*100;
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       

bool CritterGenerateCheck(const int[]&params)
{
	
	int special=0;
	for(uint i=(0);i<=(6);i++)
	{
		if(params[i]<1||params[i]>10)
		{
			Message(GetMsgStr((3),(1005)));
			return false;
		}
		special+=__RegParams[i];
	}
	if(special!=__StartSpecialPoints)
	{
		Message(GetMsgStr((3),(1005)));
		return false;
	} 
	
	if((params[(226)]<int((__SkillBegin))||params[(226)]>int((__SkillEnd)))||
	(params[(227)]<int((__SkillBegin))||params[(227)]>int((__SkillEnd)))||
	(params[(228)]<int((__SkillBegin))||params[(228)]>int((__SkillEnd))))
	{
		Message(GetMsgStr((3),(1029)));
		return false;
	}
	return true;
}            

uint CheckPlayerName(const string&name)
{
	
	if(name.length()<__MinNameLength||name.length()>__MaxNameLength)
	return(1009); 
	
	string allLetters=__ValidNameLettersCommon+__ValidNameLettersCulture1+__ValidNameLettersCulture2;
	for(uint i=0,j=name.length();i<j;i++)
	if(findFirst(allLetters,name[i])==-1)
	return(1036); 
	
	if(name[0]==" "||name[-1]==" ")
	return(1032);
	for(int i=0,j=name.length()-1;i<j;i++)
	if(name[i]==" "&&name[i+1]==" ")
	return(1033); 
	
	uint letters1=0;
	uint letters2=0;
	for(int i=0,j=name.length()-1;i<j;i++)
	{
		if(findFirst(__ValidNameLettersCulture1,name[i])!=-1)
		letters1++;
		else if(findFirst(__ValidNameLettersCulture2,name[i])!=-1)
		letters2++;
	}
	if(letters1>0&&letters2>0)
	return(1030); 
	
	if((letters1+letters2)*100/name.length()<70)
	return(1031); 
	
	return 0;
}            

int getParam_Strength(CritterCl&cr,uint)
{
	int val=cr.ParamBase[(0)]+cr.ParamBase[(32)];
	if(cr.ParamBase[(380)]!=0&&getParam_Timeout(cr,(238))!=0&&
	cr.ParamBase[(72)]<=(cr.ParamBase[(7)]+cr.ParamBase[(0)]+cr.ParamBase[(2)]*2)/2)
	val++;
	return(((val)>(10))?(10):(((val)<(1))?(1):(val)));
}

int getParam_Perception(CritterCl&cr,uint)
{
	int val=(cr.ParamBase[(502)]!=0?1:cr.ParamBase[(1)]+cr.ParamBase[(33)]);
	if(cr.ParamBase[(565)]!=0)
	val+=GetNightPersonBonus();
	return(((val)>(10))?(10):(((val)<(1))?(1):(val)));
}

int getParam_Endurance(CritterCl&cr,uint)
{
	int val=cr.ParamBase[(2)]+cr.ParamBase[(34)];
	return(((val)>(10))?(10):(((val)<(1))?(1):(val)));
}

int getParam_Charisma(CritterCl&cr,uint)
{
	int val=cr.ParamBase[(3)]+cr.ParamBase[(35)];
	return(((val)>(10))?(10):(((val)<(1))?(1):(val)));
}

int getParam_Intellegence(CritterCl&cr,uint)
{
	int val=cr.ParamBase[(4)]+cr.ParamBase[(36)];
	if(cr.ParamBase[(565)]!=0)
	val+=GetNightPersonBonus();
	return(((val)>(10))?(10):(((val)<(1))?(1):(val)));
}

int getParam_Agility(CritterCl&cr,uint)
{
	int val=cr.ParamBase[(5)]+cr.ParamBase[(37)];
	return(((val)>(10))?(10):(((val)<(1))?(1):(val)));
}

int getParam_Luck(CritterCl&cr,uint)
{
	int val=cr.ParamBase[(6)]+cr.ParamBase[(38)];
	return(((val)>(10))?(10):(((val)<(1))?(1):(val)));
}

int getParam_Hp(CritterCl&cr,uint)
{
	return cr.ParamBase[(72)];
}

int getParam_MaxLife(CritterCl&cr,uint)
{
	int val=cr.ParamBase[(7)]+cr.ParamBase[(39)]+cr.ParamBase[(0)]+cr.ParamBase[(2)]*2;
	return(((val)>(9999))?(9999):(((val)<(1))?(1):(val)));
}

int getParam_MaxAp(CritterCl&cr,uint)
{
	int val=cr.ParamBase[(8)]+cr.ParamBase[(40)]+getParam_Agility(cr,0)/2;
	return(((val)>(9999))?(9999):(((val)<(1))?(1):(val)));
}

int getParam_Ap(CritterCl&cr,uint)
{
	int val=cr.ParamBase[(75)];
	val/=(100);
	return(((val)>(9999))?(9999):(((val)<(-9999))?(-9999):(val)));
}

int getParam_MaxMoveAp(CritterCl&cr,uint)
{
	int val=cr.ParamBase[(87)];
	return(((val)>(9999))?(9999):(((val)<(0))?(0):(val)));
}

int getParam_MoveAp(CritterCl&cr,uint)
{
	int val=cr.ParamBase[(88)];
	return(((val)>(9999))?(9999):(((val)<(0))?(0):(val)));
}

int getParam_MaxWeight(CritterCl&cr,uint)
{
	int val=(((cr.ParamBase[(11)]+cr.ParamBase[(43)])>(0))?(cr.ParamBase[(11)]+cr.ParamBase[(43)]):(0));
	val+=((25+getParam_Strength(cr,0)*(25-cr.ParamBase[(552)]*10))*453);
	return(((val)>(2000000000))?(2000000000):(((val)<(0))?(0):(val)));
}

int getParam_Sequence(CritterCl&cr,uint)
{
	int val=cr.ParamBase[(12)]+cr.ParamBase[(44)]+getParam_Perception(cr,0)*2;
	return(((val)>(9999))?(9999):(((val)<(0))?(0):(val)));
}

int getParam_MeleeDmg(CritterCl&cr,uint)
{
	int strength=getParam_Strength(cr,0);
	int val=cr.ParamBase[(10)]+cr.ParamBase[(42)]+(strength>6?strength-5:1);
	return(((val)>(9999))?(9999):(((val)<(1))?(1):(val)));
}

int getParam_HealingRate(CritterCl&cr,uint)
{
	int e=getParam_Endurance(cr,0);
	int val=cr.ParamBase[(13)]+cr.ParamBase[(45)]+(((1)>(e/3))?(1):(e/3));
	return(((val)>(9999))?(9999):(((val)<(0))?(0):(val)));
}

int getParam_CriticalChance(CritterCl&cr,uint)
{
	int val=cr.ParamBase[(14)]+cr.ParamBase[(46)]+getParam_Luck(cr,0);
	return(((val)>(100))?(100):(((val)<(0))?(0):(val)));
}

int getParam_MaxCritical(CritterCl&cr,uint)
{
	int val=cr.ParamBase[(15)]+cr.ParamBase[(47)];
	return(((val)>(100))?(100):(((val)<(-100))?(-100):(val)));
}

int getParam_Ac(CritterCl&cr,uint)
{
	int val=cr.ParamBase[(9)]+cr.ParamBase[(41)]+getParam_Agility(cr,0)+cr.ParamBase[(86)];
	ItemCl@armor=cr.GetItem(0,(3));
	if((@armor!=null)&&armor.GetType()==(1))
	val+=armor.Proto.Armor_AC*(100-GetDeteriorationProc(armor))/100;
	return(((val)>(90))?(90):(((val)<(0))?(0):(val)));
}

int getParam_DamageResistance(CritterCl&cr,uint index)
{
	int dmgType=index-(23)+1;
	int val=0;
	int drVal=0;
	uint8 mode=0;
	ProtoItem@protoArmor=cr.GetSlotProto((3),mode);
	switch(dmgType)
	{
		case(1):
		val=cr.ParamBase[(23)]+cr.ParamBase[(55)];
		drVal=protoArmor.Armor_DRNormal;
		break;
		case(2):
		val=cr.ParamBase[(24)]+cr.ParamBase[(56)];
		drVal=protoArmor.Armor_DRLaser;
		break;
		case(3):
		val=cr.ParamBase[(25)]+cr.ParamBase[(57)];
		drVal=protoArmor.Armor_DRFire;
		break;
		case(4):
		val=cr.ParamBase[(26)]+cr.ParamBase[(58)];
		drVal=protoArmor.Armor_DRPlasma;
		break;
		case(5):
		val=cr.ParamBase[(27)]+cr.ParamBase[(59)];
		drVal=protoArmor.Armor_DRElectr;
		break;
		case(6):
		val=cr.ParamBase[(28)]+cr.ParamBase[(60)];
		drVal=protoArmor.Armor_DREmp;
		break;
		case(7):
		val=cr.ParamBase[(29)]+cr.ParamBase[(61)];
		drVal=protoArmor.Armor_DRExplode;
		break;
		case(0):
		default:
		break;
	}
	
	ItemCl@armor=cr.GetItem(0,(3));
	if((@armor!=null)&&armor.GetType()==(1))
	val+=drVal*(100-GetDeteriorationProc(armor))/100;
	
	if(dmgType==(6))
	return(((val)>(999))?(999):(((val)<(0))?(0):(val)));
	return(((val)>(90))?(90):(((val)<(0))?(0):(val)));
}

int getParam_DamageThreshold(CritterCl&cr,uint index)
{
	int dmgType=index-(16)+1;
	int val=0;
	int dtVal=0;
	uint8 mode=0;
	ProtoItem@protoArmor=cr.GetSlotProto((3),mode);
	switch(dmgType)
	{
		case(1):
		val=cr.ParamBase[(16)]+cr.ParamBase[(48)];
		dtVal=protoArmor.Armor_DTNormal;
		break;
		case(2):
		val=cr.ParamBase[(17)]+cr.ParamBase[(49)];
		dtVal=protoArmor.Armor_DTLaser;
		break;
		case(3):
		val=cr.ParamBase[(18)]+cr.ParamBase[(50)];
		dtVal=protoArmor.Armor_DTFire;
		break;
		case(4):
		val=cr.ParamBase[(19)]+cr.ParamBase[(51)];
		dtVal=protoArmor.Armor_DTPlasma;
		break;
		case(5):
		val=cr.ParamBase[(20)]+cr.ParamBase[(52)];
		dtVal=protoArmor.Armor_DTElectr;
		break;
		case(6):
		val=cr.ParamBase[(21)]+cr.ParamBase[(53)];
		dtVal=protoArmor.Armor_DTEmp;
		break;
		case(7):
		val=cr.ParamBase[(22)]+cr.ParamBase[(54)];
		dtVal=protoArmor.Armor_DTExplode;
		break;
		case(0):
		default:
		break;
	}
	
	ItemCl@armor=cr.GetItem(0,(3));
	if((@armor!=null)&&armor.GetType()==(1))
	val+=dtVal*(100-GetDeteriorationProc(armor))/100;
	
	return(((val)>(999))?(999):(((val)<(0))?(0):(val)));
}

int getParam_RadiationResist(CritterCl&cr,uint)
{
	int val=cr.ParamBase[(30)]+cr.ParamBase[(62)]+getParam_Endurance(cr,0)*2;
	return(((val)>(95))?(95):(((val)<(0))?(0):(val)));
}

int getParam_PoisonResist(CritterCl&cr,uint)
{
	int val=cr.ParamBase[(31)]+cr.ParamBase[(63)]+getParam_Endurance(cr,0)*5;
	return(((val)>(95))?(95):(((val)<(0))?(0):(val)));
}

int getParam_Timeout(CritterCl&cr,uint index)
{
	return uint(cr.ParamBase[index])>__FullSecond?uint(cr.ParamBase[index])-__FullSecond:0;
}

int getParam_Reputation(CritterCl&cr,uint index)
{    
	
	if(uint(cr.ParamBase[index])==0x80000000)
	return 0;
	
	return cr.ParamBase[index];
}

void changedParam_Reputation(CritterCl&cr,uint index,int oldValue)
{      
	
}  

bool Critter_IsInjured(CritterCl&cr)
{
	return Critter_IsDmgArm(cr)||Critter_IsDmgLeg(cr)||Critter_IsDmgEye(cr);
}

bool Critter_IsDmgEye(CritterCl&cr)
{
	return cr.ParamBase[(502)]!=0;
}

bool Critter_IsDmgLeg(CritterCl&cr)
{
	return cr.ParamBase[(505)]!=0||cr.ParamBase[(506)]!=0;
}

bool Critter_IsDmgTwoLeg(CritterCl&cr)
{
	return cr.ParamBase[(505)]!=0&&cr.ParamBase[(506)]!=0;
}

bool Critter_IsDmgArm(CritterCl&cr)
{
	return cr.ParamBase[(503)]!=0||cr.ParamBase[(504)]!=0;
}

bool Critter_IsDmgTwoArm(CritterCl&cr)
{
	return cr.ParamBase[(503)]!=0&&cr.ParamBase[(504)]!=0;
}

bool Critter_IsAddicted(CritterCl&cr)
{
	for(uint i=(__AddictionBegin);i<=(__AddictionEnd);i++)
	if(cr.ParamBase[i]!=0)
	return true;
	return false;
}

bool Critter_IsOverweight(CritterCl&cr)
{
	return int(cr.ItemsWeight())>getParam_MaxWeight(cr,0);
}

bool ProtoItem_Weapon_IsHtHAttack(ProtoItem&proto,uint8 mode)
{
	uint8 use=mode&0xF;
	if(proto.Type!=(3)||((proto.Weapon_ActiveUses>>use)&1)==0)
	return false;
	int skill=((use)==0?proto.Weapon_Skill_0:((use)==1?proto.Weapon_Skill_1:((use)==2?proto.Weapon_Skill_2:0)));
	return skill==(203)||skill==(204);
}

bool ProtoItem_Weapon_IsGunAttack(ProtoItem&proto,uint8 mode)
{
	uint8 use=mode&0xF;
	if(proto.Type!=(3)||((proto.Weapon_ActiveUses>>use)&1)==0)
	return false;
	int skill=((use)==0?proto.Weapon_Skill_0:((use)==1?proto.Weapon_Skill_1:((use)==2?proto.Weapon_Skill_2:0)));
	return skill==(200)||skill==(201)||skill==(202);
}

bool ProtoItem_Weapon_IsRangedAttack(ProtoItem&proto,uint8 mode)
{
	uint8 use=mode&0xF;
	if(proto.Type!=(3)||((proto.Weapon_ActiveUses>>use)&1)==0)
	return false;
	int skill=((use)==0?proto.Weapon_Skill_0:((use)==1?proto.Weapon_Skill_1:((use)==2?proto.Weapon_Skill_2:0)));
	return skill==(200)||skill==(201)||skill==(202)||skill==(205);
}  

uint GetProtoItemUseApCost(CritterCl&cr,ProtoItem&proto,uint8 mode)
{
	uint8 use=mode&0xF;
	uint8 aim=mode>>4;
	int apCost=1;
	
	if(use==(4))
	{
		if(((getParam_Timeout(cr,(238)))>10000000))
		apCost=__TbApCostUseItem;
		else
		apCost=__RtApCostUseItem;
	}
	else if(use==(3))
	{
		if(((getParam_Timeout(cr,(238)))>10000000))
		apCost=__TbApCostReloadWeapon;
		else
		apCost=__RtApCostReloadWeapon;
		
		if(proto.Type==(3)&&proto.Weapon_Perk==(6))
		apCost--;
	}
	else if(use>=(0)&&use<=(2)&&proto.Type==(3))
	{
		int skill=((use)==0?proto.Weapon_Skill_0:((use)==1?proto.Weapon_Skill_1:((use)==2?proto.Weapon_Skill_2:0)));
		bool hthAttack=ProtoItem_Weapon_IsHtHAttack(proto,use);
		bool rangedAttack=ProtoItem_Weapon_IsRangedAttack(proto,use);
		
		apCost=((use)==0?proto.Weapon_ApCost_0:((use)==1?proto.Weapon_ApCost_1:((use)==2?proto.Weapon_ApCost_2:0)));
		if(aim!=0)
		apCost+=GetAimApCost(aim);
		if(hthAttack&&cr.ParamBase[(302)]!=0)
		apCost--;
		if(rangedAttack&&cr.ParamBase[(306)]!=0)
		apCost--;
		if(cr.ParamBase[(557)]!=0&&!hthAttack)
		apCost--;
	}
	
	if(apCost<1)
	apCost=1;
	return apCost;
}

uint GetItemUseApCost(CritterCl&cr,ItemCl&item,uint8 mode)
{
	return GetProtoItemUseApCost(cr,item.Proto,mode);
}

uint get_use_ap_cost(CritterCl&cr,ItemCl&item,uint8 mode)
{
	return GetItemUseApCost(cr,item,mode);
}

uint GetProtoItemAttackDistantion(CritterCl&cr,ProtoItem&proto,uint8 mode)
{
	if(proto.Type!=(3))
	return 0;
	
	uint8 use=mode&0xF;
	int skill=((use)==0?proto.Weapon_Skill_0:((use)==1?proto.Weapon_Skill_1:((use)==2?proto.Weapon_Skill_2:0)));
	int dist=((use)==0?proto.Weapon_MaxDist_0:((use)==1?proto.Weapon_MaxDist_1:((use)==2?proto.Weapon_MaxDist_2:0)));
	int strength=getParam_Strength(cr,0);
	int heaveHo=cr.ParamBase[(336)];
	if(skill==(205))
	dist=(((dist)<(int(3)*(((int(10))<(strength+2*heaveHo))?(int(10)):(strength+2*heaveHo))))?(dist):(int(3)*(((int(10))<(strength+2*heaveHo))?(int(10)):(strength+2*heaveHo))));
	if(ProtoItem_Weapon_IsHtHAttack(proto,mode)&&cr.ParamBase[(530)]!=0)
	dist++;
	dist+=cr.GetMultihex();
	if(dist<0)
	dist=0;
	return dist;
}

uint GetItemAttackDistantion(CritterCl&cr,ItemCl&item,uint8 mode)
{
	return GetProtoItemAttackDistantion(cr,item.Proto,mode);
}

uint GetActiveItemAttackDistantion(CritterCl&cr)
{
	ItemCl@item=cr.GetItem(0,(1));
	if(item is null)
	{
		uint8 mode=0;
		ProtoItem@proto=cr.GetSlotProto((1),mode);
		return GetProtoItemAttackDistantion(cr,proto,mode);
	}
	return GetItemAttackDistantion(cr,item,item.Mode);
}

uint get_attack_distantion(CritterCl&cr,ItemCl&item,uint8 mode)
{
	return GetItemAttackDistantion(cr,item,mode);
}  

int GetNightPersonBonus()
{
	if(__Hour<6||__Hour>18)
	return 1;
	if(__Hour==6&&__Minute==0)
	return 1;
	if(__Hour==18&&__Minute>0)
	return 1;
	return-1;
}

uint GetAimApCost(int hitLocation)
{
	switch(hitLocation)
	{
		case(4):
		return __ApCostAimTorso;
		case(7):
		return __ApCostAimEyes;
		case(1):
		return __ApCostAimHead;
		case(2):
		case(3):
		return __ApCostAimArms;
		case(8):
		return __ApCostAimGroin;
		case(5):
		case(6):
		return __ApCostAimLegs;
		case(0):
		case(9):
		default:
		break;
	}
	return 0;
}

int GetDeteriorationProc(ItemCl&item)
{
	int val=item.Deterioration*100/(10000);
	return(((val)>(100))?(100):(((val)<(0))?(0):(val)));
}
